# Pre## 🔄 Restart Directi## 🔄 Restart Directive (PERMANENT RULE)

**CRITICAL**: After any substantial changes during the validation process (such as authentication system modernization, architectural refactoring, security vulnerability fixes, or significant code restructuring), the AI assistant MUST restart this entire checklist from Phase 1, Step 1.0. (PERMANENT RULE)

**CRITICAL**: After any substantial changes during the validation process (such as authentication system modernization, architectural refactoring, security vulnerability fixes, or significant code restructuring), the AI assistant MUST restart this entire checklist from Phase 1, Step 1.0.

**Rationale**: Substantial changes can introduce new issues, affect multiple subsystems, or invalidate previous validation steps. A complete restart ensures:

- All validation steps account for the latest changes
- No validation gaps from incremental checking
- Comprehensive quality assurance after architectural modifications
- Fresh evaluation of the complete system state

**Examples of changes requiring restart**:

- Authentication system modernization
- Major refactoring of core components
- Security vulnerability remediation
- API or CLI interface changes
- Cross-cutting architectural improvements

## 📋 Pre-Merge Validation Sequence

### Phase 1: Code Quality & SOLID Reviewon Checklist

## 🎯 Purpose

This checklist ensures comprehensive validation before merging code changes. It consolidates multiple testing frameworks and quality checks into a single, repeatable process that guarantees merge-readiness.

## 🔄 Restart Directive (PERMANENT RULE)

**CRITICAL**: After any substantial changes during the validation process (such as authentication system modernization, architectural refactoring, security vulnerability fixes, or significant code restructuring), the AI assistant MUST restart this entire checklist from Phase 1, Step 1.0.

**Rationale**: Substantial changes can introduce new issues, affect multiple subsystems, or invalidate previous validation steps. A complete restart ensures:

- All validation steps account for the latest changes
- No validation gaps from incremental checking
- Comprehensive quality assurance after architectural modifications
- Fresh evaluation of the complete system state

**Examples of changes requiring restart**:

- Authentication system modernization
- Major refactoring of core components
- Security vulnerability remediation
- API or CLI interface changes
- Cross-cutting architectural improvements

### Phase 1: Code Quality & SOLID Review

### Pre-Validation Setup

🚨 **Environment Token Check**:

```bash
env | grep -i simple
# If SIMPLE_SECRETS_TOKEN is set, note it in validation results!
# It auto-authenticates and can affect example testing.
```

🚨 **Installation State Check**:

```bash
ls ~/.simple-secrets
# If directory exists, you're testing existing installation behavior
# For first-run testing: rm -rf ~/.simple-secrets
# DON'T PANIC about missing first-run setup if installation already exists!
```

**Purpose**: Early validation of code architecture, clean code principles, and merge-readiness

#### 1.0 Test Suite Validation (CRITICAL FIRST STEP)

- ✅ **Build Verification**: `make clean && make dev` succeeds with current commit hash
  - ⚠️ **NEVER use `go build` directly** - always use `make dev` for proper version injection
  - ✅ **Version Check**: `./simple-secrets version` shows proper commit hash (not "unknown")
  - ✅ **Short Version**: `./simple-secrets version --short` shows `dev-abc1234` format
- ✅ **Test Execution**: `make test` runs with 100% pass rate (0 failed tests)
- ✅ **Test Coverage**: Core functionality covered by unit and integration tests
- ✅ **Concurrency Tests**: All concurrent operations tests pass without data loss
- ✅ **Performance Tests**: No regressions in test execution time
- ⚠️ **MERGE BLOCKER**: Any test failures must be fixed before proceeding

#### 1.1 SOLID Principles Review

- ✅ **Single Responsibility**: Each function/struct has one clear purpose
- ✅ **Open/Closed**: Code is extensible without modification
- ✅ **Liskov Substitution**: Interfaces are properly implemented
- ✅ **Interface Segregation**: Interfaces are focused and minimal
- ✅ **Dependency Inversion**: Dependencies are properly abstracted

#### 1.2 Clean Code Validation

- ✅ **Method Extraction**: Complex logic broken into meaningful methods
- ✅ **Variable Naming**: Names express intent clearly
- ✅ **Abstraction Levels**: Methods operate at consistent abstraction levels
- ✅ **Early Returns**: Avoid `else` branches, use guard clauses
- ✅ **Error Handling**: Clear, actionable error messages
- ✅ **Comments**: Minimal, only where absolutely necessary

#### 1.3 Organization & Structure

- ✅ **File Organization**: Related functionality properly grouped
- ✅ **Package Structure**: Clear separation of concerns
- ✅ **Import Management**: Clean, organized imports
- ✅ **Code Duplication**: No unnecessary repetition

**Expected Outcome**: Code is clean, well-organized, and follows SOLID principles

---

### Phase 2: Consistency Validation

**Purpose**: Ensures all documentation, tests, code, and examples remain synchronized after changes
**Reference**: `.copilot-consistency-checklist.md`

Execute the most thorough consistency validation possible covering:

#### 2.1 Pre-Change Analysis (Comprehensive)

- ✅ **Change Scope Documentation**: Document every file modified, added, or deleted
- ✅ **Impact Analysis**: Identify ALL files that reference changed functionality
- ✅ **Documentation Dependencies**: Map which docs, examples, and tests depend on changes
- ✅ **Version Implications**: Assess if changes affect version numbering or compatibility
- ✅ **Breaking Change Detection**: Identify any API, CLI, or behavior changes

#### 2.2 Documentation Synchronization (Exhaustive)

- ✅ **README.md**: Every feature mentioned works exactly as described
- ✅ **docs/getting-started.md**: Step-by-step guide reflects current CLI behavior
- ✅ **CLI Help Text**: `--help` output matches actual functionality for every command
- ✅ **Version Information**: All version references are current and consistent
- ✅ **Code Examples**: Every example in docs actually executes successfully
- ✅ **Security Documentation**: Current security model and recommendations
- ✅ **Installation Instructions**: Work on clean systems with specified requirements
- ✅ **Configuration Documentation**: All options documented with current defaults
- ✅ **Error Message Documentation**: Error scenarios match actual error text
- ✅ **Feature Flags**: Any conditional features properly documented

#### 2.3 Cross-Reference Validation (Complete)

- ✅ **Code-to-Docs Mapping**: Every public function/command documented somewhere
- ✅ **Example Verification**: Execute every code example in documentation
- ✅ **Link Validation**: All internal and external links work
- ✅ **Image/Diagram Currency**: Screenshots and diagrams reflect current UI/behavior
- ✅ **Test-to-Feature Mapping**: Every documented feature has corresponding tests
- ✅ **Configuration Consistency**: Default values match between code and docs
- ✅ **Command Reference**: CLI reference matches `cobra` command definitions
- ✅ **API Consistency**: Internal APIs match their usage patterns

#### 2.4 CLI Command Coverage Validation

- ✅ **Help System Audit**: `./app --help` → verify all commands listed in testing framework
- ✅ **Command Completeness**: Every command in help has corresponding test section
- ✅ **Subcommand Coverage**: Check `[command] --help` for all subcommands/flags
- ✅ **Alias Testing**: Verify all command aliases (e.g., `add` → `put`) are tested
- ✅ **Flag Coverage**: All global flags (`--version`, `-v`, `--help`, `--token`) tested
- ✅ **Command Variants**: All usage patterns and argument combinations covered
- ✅ **Error Scenarios**: Invalid commands, missing args, wrong syntax all tested

#### 2.5 Help System Consistency Validation (CRITICAL)

- ✅ **Help-to-Implementation Accuracy**: Every flag/option in help actually works as described
- ✅ **Example Execution**: All examples in help text execute successfully with expected results
- ✅ **Documentation Alignment**: README examples match help examples exactly
- ✅ **Flag Consistency**: Same flags described consistently across all commands
- ✅ **Terminology Consistency**: Same terms used consistently throughout help system
- ✅ **Feature Coverage**: All implemented features mentioned in appropriate help sections
- ✅ **Testing Framework Sync**: Help system changes reflected in testing framework command inventory

#### 2.6 Unit Test Coverage Validation

- ✅ **Test-to-Code Mapping**: Every public function has corresponding unit test
- ✅ **Critical Path Coverage**: All error handling paths have test coverage
- ✅ **Edge Case Testing**: Boundary conditions, null inputs, empty values tested
- ✅ **Mock Validation**: External dependencies properly mocked and tested
- ✅ **Integration Points**: All module interactions have integration tests
- ✅ **Regression Coverage**: Previously fixed bugs have regression tests
- ✅ **Performance Tests**: Critical operations have performance validation

#### 2.7 Quality Standards Validation

- ✅ **Documentation Quality**: Clear, actionable, error-free writing
- ✅ **Example Quality**: Examples are realistic, useful, and current
- ✅ **User Experience**: Documentation flows logically for intended audience
- ✅ **Accessibility**: Documentation is clear for users at different skill levels
- ✅ **Completeness**: No gaps between what code does and what docs say

**Expected Outcome**: Perfect synchronization between code, documentation, examples, and tests

---

### Phase 3: Persona-Based Testing Framework

**Purpose**: AI simulating different user personas testing their perception and experience with the application
**Reference**: `.persona-based-testing-guide.md`

Execute the complete persona-based testing framework covering:

- ✅ **Discovery & Learning Phase**: New user first-time experience testing
- ✅ **Destructive Creativity Phase**: Active attempts to break functionality
- ✅ **Behavioral Exploration Phase**: Boundary testing and edge case discovery
- ✅ **Critical Bug Hunt Scenarios**: Security auditor, disaster recovery, integration testing
- ✅ **All Testing Personas**: New User, Power User, Malicious Actor, DevOps Engineer, Data Analyst, Chaos Agent
- ✅ **AI-Specific Testing**: Pattern recognition, natural language exploitation, sequence prediction
- ✅ **Gamified Challenges**: Speedrun corruption, secret hoarder, token collector, time traveler, minimalist, maximalist
- ✅ **Iterative Testing Cycles**: Innocent explorer → Power user → Hostile actor → Production simulator → Integration tester
- ✅ **Creative Edge Cases**: Multi-persona combinations, compound failure scenarios, interaction bugs

**Expected Outcome**: All personas tested, creative edge cases discovered, no critical security or functionality issues, concurrent operations validated

---

### Phase 4: Standard Testing Framework

**Purpose**: AI systematically executes the comprehensive manual testing checklist for semantic correctness and real-world functionality validation
**Reference**: `.testing-framework.md`

Execute the complete testing framework covering:

- ✅ Build & Installation Testing (dev builds, version validation)
- ✅ Initial Setup & First Run Protection
- ✅ Authentication & Authorization (token validation, RBAC)
- ✅ Secret Management (CRUD operations, large data, special characters)
- ✅ User Management & Role Enforcement
- ✅ Master Key Rotation & Backup Integrity (critical focus area)
- ✅ Backup & Restore Operations
- ✅ Consolidated Commands & Legacy Compatibility
- ✅ Error Handling & Edge Cases
- ✅ Performance & Load Testing
- ✅ **Concurrent Operations Testing** (file locking, race conditions, data integrity)

**Expected Outcome**: All manual testing checklist items pass with no critical issues

---

### Phase 5: Cross-Reference Validation

**Purpose**: Ensure all framework files are properly integrated and documented

- ✅ **Framework Integration**: All testing frameworks reference each other appropriately
- ✅ **Documentation Cross-References**: Files properly link to related frameworks
- ✅ **Copilot Instructions**: `.github/copilot-instructions.md` explains usage of all frameworks
- ✅ **Usage Examples**: Clear examples of how to execute each framework

**Expected Outcome**: Complete, integrated documentation ecosystem

---

## 🚀 Execution Instructions

## Usage Instructions

### For AI Assistants

When user says "run pre-merge checklist" or references this file:

1. **Load Context**: Read all referenced framework files
2. **Execute Sequentially**: Run each phase in order, don't skip steps
3. **Report Results**: Provide clear pass/fail status for each phase
4. **Block on Failures**: Don't proceed to next phase if critical issues found
5. **Final Recommendation**: Clear go/no-go decision for merge

### For Human Developers

```bash
# Quick validation commands
make test                    # Unit tests
make integration-test        # Integration tests
make dev                     # Verify build and version
./simple-secrets --help      # Verify CLI functionality
```

## 📁 Related Files

- **Testing Frameworks**:
  - `.persona-based-testing-guide.md` - AI simulating user personas and perceptions
  - `.testing-framework.md` - AI simulating rigorous human testing for semantic correctness
  - `.copilot-consistency-checklist.md` - Documentation synchronization

- **Code Guidelines**:
  - `.github/copilot-instructions.md` - Coding standards and AI guidance
  - `VERSION_GUIDE.md` - Versioning and release process

- **Development Tools**:
  - `Makefile` - Build and test automation
  - `TODO.md` - Development tracking

## 🎯 Success Criteria

**Merge is approved when:**

- ✅ All persona-based testing framework sections pass
- ✅ All standard tests pass with no regressions
- ✅ Concurrent operations validated (no race conditions or data loss)
- ✅ Documentation is fully synchronized and consistent
- ✅ Code follows SOLID principles and clean code standards
- ✅ All framework files are cross-referenced and integrated
- ✅ No critical issues or technical debt introduced

**Merge is blocked when:**

- ❌ Any test failures in critical functionality
- ❌ Documentation inconsistencies or gaps
- ❌ Code quality violations or technical debt
- ❌ Missing test coverage for new functionality
- ❌ SOLID principle violations or poor organization

---

*This checklist ensures that every merge maintains the highest standards of quality, consistency, and maintainability.*
